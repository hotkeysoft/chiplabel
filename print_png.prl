#!/usr/bin/perl
use strict;
use warnings;

use GD;
use Getopt::Long;

my $tapewidth = 12;
my $cut = 0;
my $count = 1;
my $out = undef;
my $mirror = 0;

my $printername = "Brother_PT-2430PC";
GetOptions(
    "P=s" => \$printername,
    "w=n" => \$tapewidth,
    c => \$cut,
    "n=n" => \$count,
    "o=s" => \$out,
    m => \$mirror
    ) or die "invalid options";

# This maps the tape width from mm to pixels
# Note that we use a 2 pixel (one in each side) margin,
# the Brother driver uses a much wider margin.
my %WIDTH =
    (
     6=>42-2,
     9=>64-2,
     12=>84-2,
     18=>128-2,
     24=>128,
     );

my $opt = {cut=>$cut, mirror=>$mirror, feed=>0};

# returns true if pixel is black, zero if it is white or undef if out of bounds.
sub checkPixel {
    my ($img,$x,$y) = @_;
    my ($w,$h) = $img->getBounds();
    return undef if $x < 0 || $x >= $w || $y < 0 || $y >= $h;
    my ($r,$g,$b) = $img->rgb($img->getPixel($x,$y));
    return $r + $g + $b > 127*3 ? 0 : 1;
}

sub pprint {
    my $out = "";
    while (@_) {
	my $img = shift @_;
	my ($w,$h) = $img->getBounds();
	my $y0 = 64 - $h/2;
	for my $x (0..$w-1) {
	    my @bytes;
	    for my $x (0..15) {
		push @bytes, 0;
	    }
	    for my $y (0..127) {
		my $set = $y > 64-$WIDTH{$tapewidth}/2 && $y < 64+$WIDTH{$tapewidth}/2;
		$set = 0 unless checkPixel($img, $x, $y - $y0);
		if ($set) {
		    my $bit = 2** (7-($y % 8));
		    $bytes[int($y / 8)] |= $bit;
		}
	    }
	    # Chop off the bytes that are zero.
	    pop @bytes while @bytes and !$bytes[@bytes-1];

	    if (!@bytes) {
                $out .= 'Z';
	    } else {
		my $data = join '', map {chr} @bytes;
		$out .= 'G'.chr(@bytes).chr(0).$data;
	    }
	}
	if (@_) {
	    $out .= chr(0x0C); # There are more pages to print, don't discharge.
	} else {
	    $out .= chr(0x1A); # This is the last page, discharge.
	}
    }
    return $out;
}

sub initialize {
    my $output=chr(0x1B).'@';
    $output .= chr(0x1B).'iS';
    $output .= chr(0x1B).'iR'.chr(0x01);
    my $mode =  $cut ? 64 : 0 | $mirror ? 128 : 0;
    $output .= chr(0x1B).'iM'.chr($mode);  # Set mode
    return $output;
}

my $rawdata=pprint(map { (GD::Image->newFromPng($_)) x $count } @ARGV);
if (defined $out) {
open PRINT, ">", $out or die "$!: $out";
} else {
open PRINT, "| lpr -P$printername" or die "$!: | lpr -P$printername";
}
binmode PRINT;
print PRINT initialize();
print PRINT $rawdata;
close PRINT;
